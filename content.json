{"meta":{"title":"消波块","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-05-08T03:14:28.000Z","updated":"2021-05-10T01:40:08.000Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"起风了～"},{"title":"所有分类","date":"2021-05-08T03:00:43.000Z","updated":"2021-05-10T01:27:50.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2021-05-08T03:05:01.000Z","updated":"2021-05-08T03:05:28.000Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-05-08T03:02:11.000Z","updated":"2021-05-10T01:25:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java泛型","slug":"Java泛型","date":"2021-09-23T07:24:46.000Z","updated":"2021-09-23T07:26:27.122Z","comments":true,"path":"2021/09/23/Java泛型/","link":"","permalink":"http://example.com/2021/09/23/Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"1. 概述泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 123泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 2. 一个栗子一个被举了无数次的例子： 12345678List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);&#125; 毫无疑问，程序的运行结果会以崩溃结束： 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 3. 特性泛型只在编译阶段有效。看下面的代码： 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);&#125; 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 4. 泛型的使用泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 4.1 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）： 123456class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 12345678//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey()); 1212-27 09:20:04.432 13063-13063/? D/泛型测试: key is 12345612-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 看一个例子： 123456789Generic generic = new Generic(&quot;111111&quot;);Generic generic1 = new Generic(4444);Generic generic2 = new Generic(55.55);Generic generic3 = new Generic(false);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey()); 1234D/泛型测试: key is 111111D/泛型测试: key is 4444D/泛型测试: key is 55.55D/泛型测试: key is false 注意： 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic){ } 4.2 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，未传入泛型实参时： 1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类，传入泛型实参时： 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 4.3 泛型通配符我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic&lt;Ingeter&gt;与Generic&lt;Number&gt;实际上是相同的一种基本类型。那么问题来了，在使用Generic&lt;Number&gt;作为形参的方法中，能否使用Generic&lt;Ingeter&gt;的实例传入呢？在逻辑上类似于Generic&lt;Number&gt;和Generic&lt;Ingeter&gt;是否可以看成具有父子关系的泛型类型呢？ 为了弄清楚这个问题，我们使用Generic&lt;T&gt;这个泛型类继续看下面的例子： 123public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 12345678Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);showKeyValue(gNumber);// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt;// showKeyValue(gInteger); 通过提示信息我们可以看到Generic&lt;Integer&gt;不能被看作为``Generic`的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic&lt;Integer&gt;类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic&lt;Integer&gt;和Generic&lt;Number&gt;父类的引用类型。由此类型通配符应运而生。 我们可以将上面的方法改一下： 123public void showKeyValue1(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 4.4 泛型方法在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。 1尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。 123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 1Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;)); 4.4.1 泛型方法的基本用法光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot; * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot; * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot; * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 4.4.2 类中的泛型方法当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return &quot;fruit&quot;; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return &quot;apple&quot;; &#125; &#125; class Person&#123; @Override public String toString() &#123; return &quot;Person&quot;; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 4.4.3 泛型方法与可变参数再看一个泛型方法和可变参数的例子： 123456public &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t); &#125;&#125;printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55); 4.4.4 静态方法与泛型静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 4.4.5 泛型方法总结泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则： 12345无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 4.5 泛型上下边界在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 123public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 1234567891011Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类//showKeyValue1(generic1);showKeyValue1(generic2);showKeyValue1(generic3);showKeyValue1(generic4); 如果我们把泛型类的定义也改一下: 1234567891011public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125; 12//这一行代码也会报错，因为String不是Number的子类Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;); 再来一个泛型方法的例子： 1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); T test = container.getKey(); return test;&#125; 通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。 4.6 关于泛型数组要提一下看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。 也就是说下面的这个例子是不可以的： 1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10]; 而使用通配符创建泛型数组是可以的，如下面这个例子： 1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; 这样也是可以的： 1List&lt;String&gt;[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题： 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 123这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。 1234567List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK 5. 最后本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。","categories":[],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2021-09-15T01:55:13.000Z","updated":"2021-09-23T07:27:55.565Z","comments":true,"path":"2021/09/15/markdown语法/","link":"","permalink":"http://example.com/2021/09/15/markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一、标题在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个… 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]},{"title":"中文标题","slug":"中文标题","date":"2021-09-12T05:55:04.000Z","updated":"2021-09-12T05:57:13.148Z","comments":true,"path":"2021/09/12/中文标题/","link":"","permalink":"http://example.com/2021/09/12/%E4%B8%AD%E6%96%87%E6%A0%87%E9%A2%98/","excerpt":"","text":"中文标题文字 二级标题EnglishThis is ~.","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"中文测试","slug":"中文测试","permalink":"http://example.com/tags/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/"}]},{"title":"test","slug":"test","date":"2021-05-08T03:18:14.000Z","updated":"2021-05-08T03:39:28.000Z","comments":true,"path":"2021/05/08/test/","link":"","permalink":"http://example.com/2021/05/08/test/","excerpt":"","text":"测试文字","categories":[{"name":"文字","slug":"文字","permalink":"http://example.com/categories/%E6%96%87%E5%AD%97/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"文字","slug":"文字","permalink":"http://example.com/categories/%E6%96%87%E5%AD%97/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"},{"name":"中文测试","slug":"中文测试","permalink":"http://example.com/tags/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}