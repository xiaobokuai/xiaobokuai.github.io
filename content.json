{"meta":{"title":"消波块","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-05-08T03:14:28.000Z","updated":"2024-08-07T07:55:09.818Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"关于～"},{"title":"所有分类","date":"2021-05-08T03:00:43.000Z","updated":"2021-05-10T01:27:50.000Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2021-05-08T03:05:01.000Z","updated":"2021-05-08T03:05:28.000Z","comments":true,"path":"search/index.html","permalink":"http://example.com/search/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2021-05-08T03:02:11.000Z","updated":"2021-05-10T01:25:36.000Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"为什么 Java 中只有值传递？","slug":"why-there-only-value-passing-in-java","date":"2024-08-07T07:58:01.147Z","updated":"2023-03-23T06:17:54.474Z","comments":true,"path":"2024/08/07/why-there-only-value-passing-in-java/","link":"","permalink":"http://example.com/2024/08/07/why-there-only-value-passing-in-java/","excerpt":"","text":"开始之前，我们先来搞懂下面这两个概念： 形参&amp;实参 值传递&amp;引用传递 形参&amp;实参方法的定义可能会用到 参数（有参的方法），参数在程序语言中分为： 实参（实际参数，Arguments） ：用于传递给函数/方法的参数，必须有确定的值。 形参（形式参数，Parameters） ：用于定义函数/方法，接收实参，不需要有确定的值。 1234567String hello = &quot;Hello!&quot;;// hello 为实参sayHello(hello);// str 为形参void sayHello(String str) &#123; System.out.println(str);&#125; 值传递&amp;引用传递程序设计语言将实参传递给方法（或函数）的方式分为两种： 值传递 ：方法接收的是实参值的拷贝，会创建副本。 引用传递 ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。 很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。 为什么 Java 只有值传递？为什么说 Java 只有值传递呢？ 不需要太多废话，我通过 3 个例子来给大家证明。 案例1：传递基本类型参数代码： 123456789101112131415public static void main(String[] args) &#123; int num1 = 10; int num2 = 20; swap(num1, num2); System.out.println(&quot;num1 = &quot; + num1); System.out.println(&quot;num2 = &quot; + num2);&#125;public static void swap(int a, int b) &#123; int temp = a; a = b; b = temp; System.out.println(&quot;a = &quot; + a); System.out.println(&quot;b = &quot; + b);&#125; 输出： 1234a = 20b = 10num1 = 10num2 = 20 解析： 在 swap() 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 的值，只是从 num1、num2 的复制过来的。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。 通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样，请看案例2。 案例2：传递引用类型参数1代码： 1234567891011public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; System.out.println(arr[0]); change(arr); System.out.println(arr[0]);&#125;public static void change(int[] array) &#123; // 将数组的第一个元素变为0 array[0] = 0;&#125; 输出： 1210 解析： 看了这个案例很多人肯定觉得 Java 对引用类型的参数采用的是引用传递。 实际上，并不是的，这里传递的还是值，不过，这个值是实参的地址罢了！ 也就是说 change 方法的参数拷贝的是 arr （实参）的地址，因此，它和 arr 指向的是同一个数组对象。这也就说明了为什么方法内部对形参的修改会影响到实参。 为了更强有力地反驳 Java 对引用类型的参数采用的不是引用传递，我们再来看下面这个案例！ 案例3 ：传递引用类型参数21234567891011121314151617181920public class Person &#123; private String name; // 省略构造函数、Getter&amp;Setter方法&#125;public static void main(String[] args) &#123; Person xiaoZhang = new Person(&quot;小张&quot;); Person xiaoLi = new Person(&quot;小李&quot;); swap(xiaoZhang, xiaoLi); System.out.println(&quot;xiaoZhang:&quot; + xiaoZhang.getName()); System.out.println(&quot;xiaoLi:&quot; + xiaoLi.getName());&#125;public static void swap(Person person1, Person person2) &#123; Person temp = person1; person1 = person2; person2 = temp; System.out.println(&quot;person1:&quot; + person1.getName()); System.out.println(&quot;person2:&quot; + person2.getName());&#125; 输出: 1234person1:小李person2:小张xiaoZhang:小张xiaoLi:小李 解析： 怎么回事？？？两个引用类型的形参互换并没有影响实参啊！ swap 方法的参数 person1 和 person2 只是拷贝的实参 xiaoZhang 和 xiaoLi 的地址。因此， person1 和 person2 的互换只是拷贝的两个地址的互换罢了，并不会影响到实参 xiaoZhang 和 xiaoLi 。 引用传递是怎么样的？看到这里，相信你已经知道了 Java 中只有值传递，是没有引用传递的。但是，引用传递到底长什么样呢？下面以 C++ 的代码为例，让你看一下引用传递的庐山真面目。 12345678910111213141516#include &lt;iostream&gt;void incr(int&amp; num)&#123; std::cout &lt;&lt; &quot;incr before: &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;; num++; std::cout &lt;&lt; &quot;incr after: &quot; &lt;&lt; num &lt;&lt; &quot;\\n&quot;;&#125;int main()&#123; int age = 10; std::cout &lt;&lt; &quot;invoke before: &quot; &lt;&lt; age &lt;&lt; &quot;\\n&quot;; incr(*age); std::cout &lt;&lt; &quot;invoke after: &quot; &lt;&lt; age &lt;&lt; &quot;\\n&quot;;&#125; 输出结果： 1234invoke before: 10incr before: 10incr after: 11invoke after: 11 分析：可以看到，在 incr 函数中对形参的修改，可以影响到实参的值。要注意：这里的 incr 形参的数据类型用的是 int&amp; 才为引用传递，如果是用 int 的话还是值传递哦！ 为什么 Java 不引入引用传递呢？引用传递看似很好，能在方法内就直接把实参的值修改了，但是，为什么 Java 不引入引用传递呢？ 注意：以下为个人观点看法，并非来自于 Java 官方： 出于安全考虑，方法内部对值进行的操作，对于调用者都是未知的（把方法定义为接口，调用方不关心具体实现）。你也想象一下，如果拿着银行卡去取钱，取的是 100，扣的是 200，是不是很可怕。 Java 之父 James Gosling 在设计之初就看到了 C、C++ 的许多弊端，所以才想着去设计一门新的语言 Java。在他设计 Java 的时候就遵循了简单易用的原则，摒弃了许多开发者一不留意就会造成问题的“特性”，语言本身的东西少了，开发者要学习的东西也少了。 总结Java 中将实参传递给方法（或函数）的方式是 值传递 ： 如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。 如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。 参考 《Java 核心技术卷 Ⅰ》基础知识第十版第四章 4.5 小节 Java 到底是值传递还是引用传递？ - Hollis的回答 - 知乎 Oracle Java Tutorials - Passing Information to a Method or a Constructor Interview with James Gosling, Father of Java","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"ThreadLocal 详解","slug":"threadlocal","date":"2024-08-07T07:58:01.147Z","updated":"2023-03-23T06:18:10.487Z","comments":true,"path":"2024/08/07/threadlocal/","link":"","permalink":"http://example.com/2024/08/07/threadlocal/","excerpt":"","text":"本文来自一枝花算不算浪漫投稿， 原文地址：https://juejin.cn/post/6844904151567040519。 前言 全文共 10000+字，31 张图，这篇文章同样耗费了不少的时间和精力才创作完成，原创不易，请大家点点关注+在看，感谢。 对于ThreadLocal，大家的第一反应可能是很简单呀，线程的变量副本，每个线程隔离。那这里有几个问题大家可以思考一下： ThreadLocal的 key 是弱引用，那么在 ThreadLocal.get()的时候，发生GC之后，key 是否为null？ ThreadLocal中ThreadLocalMap的数据结构？ ThreadLocalMap的Hash 算法？ ThreadLocalMap中Hash 冲突如何解决？ ThreadLocalMap的扩容机制？ ThreadLocalMap中过期 key 的清理机制？探测式清理和启发式清理流程？ ThreadLocalMap.set()方法实现原理？ ThreadLocalMap.get()方法实现原理？ 项目中ThreadLocal使用情况？遇到的坑？ …… 上述的一些问题你是否都已经掌握的很清楚了呢？本文将围绕这些问题使用图文方式来剖析ThreadLocal的点点滴滴。 目录注明： 本文源码基于JDK 1.8 ThreadLocal代码演示我们先看下ThreadLocal使用示例： 1234567891011121314151617181920212223public class ThreadLocalTest &#123; private List&lt;String&gt; messages = Lists.newArrayList(); public static final ThreadLocal&lt;ThreadLocalTest&gt; holder = ThreadLocal.withInitial(ThreadLocalTest::new); public static void add(String message) &#123; holder.get().messages.add(message); &#125; public static List&lt;String&gt; clear() &#123; List&lt;String&gt; messages = holder.get().messages; holder.remove(); System.out.println(&quot;size: &quot; + holder.get().messages.size()); return messages; &#125; public static void main(String[] args) &#123; ThreadLocalTest.add(&quot;一枝花算不算浪漫&quot;); System.out.println(holder.get().messages); ThreadLocalTest.clear(); &#125;&#125; 打印结果： 12[一枝花算不算浪漫]size: 0 ThreadLocal对象可以提供线程局部变量，每个线程Thread拥有一份自己的副本变量，多个线程互不干扰。 ThreadLocal的数据结构 Thread类有一个类型为ThreadLocal.ThreadLocalMap的实例变量threadLocals，也就是说每个线程有一个自己的ThreadLocalMap。 ThreadLocalMap有自己的独立实现，可以简单地将它的key视作ThreadLocal，value为代码中放入的值（实际上key并不是ThreadLocal本身，而是它的一个弱引用）。 每个线程在往ThreadLocal里放值的时候，都会往自己的ThreadLocalMap里存，读也是以ThreadLocal作为引用，在自己的map里找对应的key，从而实现了线程隔离。 ThreadLocalMap有点类似HashMap的结构，只是HashMap是由数组+链表实现的，而ThreadLocalMap中并没有链表结构。 我们还要注意Entry， 它的key是ThreadLocal&lt;?&gt; k ，继承自WeakReference， 也就是我们常说的弱引用类型。 GC 之后 key 是否为 null？回应开头的那个问题， ThreadLocal 的key是弱引用，那么在ThreadLocal.get()的时候，发生GC之后，key是否是null？ 为了搞清楚这个问题，我们需要搞清楚Java的四种引用类型： 强引用：我们常常 new 出来的对象就是强引用类型，只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足的时候 软引用：使用 SoftReference 修饰的对象被称为软引用，软引用指向的对象在内存要溢出的时候被回收 弱引用：使用 WeakReference 修饰的对象被称为弱引用，只要发生垃圾回收，若这个对象只被弱引用指向，那么就会被回收 虚引用：虚引用是最弱的引用，在 Java 中使用 PhantomReference 进行定义。虚引用中唯一的作用就是用队列接收对象即将死亡的通知 接着再来看下代码，我们使用反射的方式来看看GC后ThreadLocal中的数据情况：(下面代码来源自：https://blog.csdn.net/thewindkee/article/details/103726942 本地运行演示 GC 回收场景) 123456789101112131415161718192021222324252627282930313233343536373839404142public class ThreadLocalDemo &#123; public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException, InterruptedException &#123; Thread t = new Thread(()-&gt;test(&quot;abc&quot;,false)); t.start(); t.join(); System.out.println(&quot;--gc后--&quot;); Thread t2 = new Thread(() -&gt; test(&quot;def&quot;, true)); t2.start(); t2.join(); &#125; private static void test(String s,boolean isGC) &#123; try &#123; new ThreadLocal&lt;&gt;().set(s); if (isGC) &#123; System.gc(); &#125; Thread t = Thread.currentThread(); Class&lt;? extends Thread&gt; clz = t.getClass(); Field field = clz.getDeclaredField(&quot;threadLocals&quot;); field.setAccessible(true); Object ThreadLocalMap = field.get(t); Class&lt;?&gt; tlmClass = ThreadLocalMap.getClass(); Field tableField = tlmClass.getDeclaredField(&quot;table&quot;); tableField.setAccessible(true); Object[] arr = (Object[]) tableField.get(ThreadLocalMap); for (Object o : arr) &#123; if (o != null) &#123; Class&lt;?&gt; entryClass = o.getClass(); Field valueField = entryClass.getDeclaredField(&quot;value&quot;); Field referenceField = entryClass.getSuperclass().getSuperclass().getDeclaredField(&quot;referent&quot;); valueField.setAccessible(true); referenceField.setAccessible(true); System.out.println(String.format(&quot;弱引用key:%s,值:%s&quot;, referenceField.get(o), valueField.get(o))); &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 结果如下： 1234弱引用key:java.lang.ThreadLocal@433619b6,值:abc弱引用key:java.lang.ThreadLocal@418a15e3,值:java.lang.ref.SoftReference@bf97a12--gc后--弱引用key:null,值:def 如图所示，因为这里创建的ThreadLocal并没有指向任何值，也就是没有任何引用： 1new ThreadLocal&lt;&gt;().set(s); 所以这里在GC之后，key就会被回收，我们看到上面debug中的referent=null, 如果改动一下代码： 这个问题刚开始看，如果没有过多思考，弱引用，还有垃圾回收，那么肯定会觉得是null。 其实是不对的，因为题目说的是在做 ThreadLocal.get() 操作，证明其实还是有强引用存在的，所以 key 并不为 null，如下图所示，ThreadLocal的强引用仍然是存在的。 如果我们的强引用不存在的话，那么 key 就会被回收，也就是会出现我们 value 没被回收，key 被回收，导致 value 永远存在，出现内存泄漏。 ThreadLocal.set()方法源码详解 ThreadLocal中的set方法原理如上图所示，很简单，主要是判断ThreadLocalMap是否存在，然后使用ThreadLocal中的set方法进行数据处理。 代码如下： 123456789101112public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; 主要的核心逻辑还是在ThreadLocalMap中的，一步步往下看，后面还有更详细的剖析。 ThreadLocalMap Hash 算法既然是Map结构，那么ThreadLocalMap当然也要实现自己的hash算法来解决散列表数组冲突问题。 1int i = key.threadLocalHashCode &amp; (len-1); ThreadLocalMap中hash算法很简单，这里i就是当前 key 在散列表中对应的数组下标位置。 这里最关键的就是threadLocalHashCode值的计算，ThreadLocal中有一个属性为HASH_INCREMENT = 0x61c88647 12345678910111213141516171819202122public class ThreadLocal&lt;T&gt; &#123; private final int threadLocalHashCode = nextHashCode(); private static AtomicInteger nextHashCode = new AtomicInteger(); private static final int HASH_INCREMENT = 0x61c88647; private static int nextHashCode() &#123; return nextHashCode.getAndAdd(HASH_INCREMENT); &#125; static class ThreadLocalMap &#123; ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY); &#125; &#125;&#125; 每当创建一个ThreadLocal对象，这个ThreadLocal.nextHashCode 这个值就会增长 0x61c88647 。 这个值很特殊，它是斐波那契数 也叫 黄金分割数。hash增量为 这个数字，带来的好处就是 hash 分布非常均匀。 我们自己可以尝试下： 可以看到产生的哈希码分布很均匀，这里不去细纠斐波那契具体算法，感兴趣的可以自行查阅相关资料。 ThreadLocalMap Hash 冲突 注明： 下面所有示例图中，绿色块Entry代表正常数据，灰色块代表Entry的key值为null，已被垃圾回收。白色块表示Entry为null。 虽然ThreadLocalMap中使用了黄金分割数来作为hash计算因子，大大减少了Hash冲突的概率，但是仍然会存在冲突。 HashMap中解决冲突的方法是在数组上构造一个链表结构，冲突的数据挂载到链表上，如果链表长度超过一定数量则会转化成红黑树。 而 ThreadLocalMap 中并没有链表结构，所以这里不能使用 HashMap 解决冲突的方式了。 如上图所示，如果我们插入一个value=27的数据，通过 hash 计算后应该落入槽位 4 中，而槽位 4 已经有了 Entry 数据。 此时就会线性向后查找，一直找到 Entry 为 null 的槽位才会停止查找，将当前元素放入此槽位中。当然迭代过程中还有其他的情况，比如遇到了 Entry 不为 null 且 key 值相等的情况，还有 Entry 中的 key 值为 null 的情况等等都会有不同的处理，后面会一一详细讲解。 这里还画了一个Entry中的key为null的数据（Entry=2 的灰色块数据），因为key值是弱引用类型，所以会有这种数据存在。在set过程中，如果遇到了key过期的Entry数据，实际上是会进行一轮探测式清理操作的，具体操作方式后面会讲到。 ThreadLocalMap.set()详解ThreadLocalMap.set()原理图解看完了ThreadLocal hash 算法后，我们再来看set是如何实现的。 往ThreadLocalMap中set数据（新增或者更新数据）分为好几种情况，针对不同的情况我们画图来说明。 第一种情况： 通过hash计算后的槽位对应的Entry数据为空： 这里直接将数据放到该槽位即可。 第二种情况： 槽位数据不为空，key值与当前ThreadLocal通过hash计算获取的key值一致： 这里直接更新该槽位的数据。 第三种情况： 槽位数据不为空，往后遍历过程中，在找到Entry为null的槽位之前，没有遇到key过期的Entry： 遍历散列数组，线性往后查找，如果找到Entry为null的槽位，则将数据放入该槽位中，或者往后遍历过程中，遇到了key 值相等的数据，直接更新即可。 第四种情况： 槽位数据不为空，往后遍历过程中，在找到Entry为null的槽位之前，遇到key过期的Entry，如下图，往后遍历过程中，遇到了index=7的槽位数据Entry的key=null： 散列数组下标为 7 位置对应的Entry数据key为null，表明此数据key值已经被垃圾回收掉了，此时就会执行replaceStaleEntry()方法，该方法含义是替换过期数据的逻辑，以index=7位起点开始遍历，进行探测式数据清理工作。 初始化探测式清理过期数据扫描的开始位置：slotToExpunge = staleSlot = 7 以当前staleSlot开始 向前迭代查找，找其他过期的数据，然后更新过期数据起始扫描下标slotToExpunge。for循环迭代，直到碰到Entry为null结束。 如果找到了过期的数据，继续向前迭代，直到遇到Entry=null的槽位才停止迭代，如下图所示，slotToExpunge 被更新为 0： 以当前节点(index=7)向前迭代，检测是否有过期的Entry数据，如果有则更新slotToExpunge值。碰到null则结束探测。以上图为例slotToExpunge被更新为 0。 上面向前迭代的操作是为了更新探测清理过期数据的起始下标slotToExpunge的值，这个值在后面会讲解，它是用来判断当前过期槽位staleSlot之前是否还有过期元素。 接着开始以staleSlot位置(index=7)向后迭代，如果找到了相同 key 值的 Entry 数据： 从当前节点staleSlot向后查找key值相等的Entry元素，找到后更新Entry的值并交换staleSlot元素的位置(staleSlot位置为过期元素)，更新Entry数据，然后开始进行过期Entry的清理工作，如下图所示： 向后遍历过程中，如果没有找到相同 key 值的 Entry 数据： 从当前节点staleSlot向后查找key值相等的Entry元素，直到Entry为null则停止寻找。通过上图可知，此时table中没有key值相同的Entry。 创建新的Entry，替换table[stableSlot]位置： 替换完成后也是进行过期元素清理工作，清理工作主要是有两个方法：expungeStaleEntry()和cleanSomeSlots()，具体细节后面会讲到，请继续往后看。 ThreadLocalMap.set()源码详解上面已经用图的方式解析了set()实现的原理，其实已经很清晰了，我们接着再看下源码： java.lang.ThreadLocal.ThreadLocalMap.set(): 1234567891011121314151617181920212223242526private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; Entry[] tab = table; int len = tab.length; int i = key.threadLocalHashCode &amp; (len-1); for (Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; return; &#125; if (k == null) &#123; replaceStaleEntry(key, value, i); return; &#125; &#125; tab[i] = new Entry(key, value); int sz = ++size; if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125; 这里会通过key来计算在散列表中的对应位置，然后以当前key对应的桶的位置向后查找，找到可以使用的桶。 123Entry[] tab = table;int len = tab.length;int i = key.threadLocalHashCode &amp; (len-1); 什么情况下桶才是可以使用的呢？ k = key 说明是替换操作，可以使用 碰到一个过期的桶，执行替换逻辑，占用过期桶 查找过程中，碰到桶中Entry=null的情况，直接使用 接着就是执行for循环遍历，向后查找，我们先看下nextIndex()、prevIndex()方法实现： 1234567private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125;private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1);&#125; 接着看剩下for循环中的逻辑： 遍历当前key值对应的桶中Entry数据为空，这说明散列数组这里没有数据冲突，跳出for循环，直接set数据到对应的桶中 如果key值对应的桶中Entry数据不为空2.1 如果k = key，说明当前set操作是一个替换操作，做替换逻辑，直接返回2.2 如果key = null，说明当前桶位置的Entry是过期数据，执行replaceStaleEntry()方法(核心方法)，然后返回 for循环执行完毕，继续往下执行说明向后迭代的过程中遇到了entry为null的情况3.1 在Entry为null的桶中创建一个新的Entry对象3.2 执行++size操作 调用cleanSomeSlots()做一次启发式清理工作，清理散列数组中Entry的key过期的数据4.1 如果清理工作完成后，未清理到任何数据，且size超过了阈值(数组长度的 2/3)，进行rehash()操作4.2 rehash()中会先进行一轮探测式清理，清理过期key，清理完成后如果size &gt;= threshold - threshold / 4，就会执行真正的扩容逻辑(扩容逻辑往后看) 接着重点看下replaceStaleEntry()方法，replaceStaleEntry()方法提供替换过期数据的功能，我们可以对应上面第四种情况的原理图来再回顾下，具体代码如下： java.lang.ThreadLocal.ThreadLocalMap.replaceStaleEntry(): 123456789101112131415161718192021222324252627282930313233343536373839404142private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; Entry[] tab = table; int len = tab.length; Entry e; int slotToExpunge = staleSlot; for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; tab[staleSlot].value = null; tab[staleSlot] = new Entry(key, value); if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);&#125; slotToExpunge表示开始探测式清理过期数据的开始下标，默认从当前的staleSlot开始。以当前的staleSlot开始，向前迭代查找，找到没有过期的数据，for循环一直碰到Entry为null才会结束。如果向前找到了过期数据，更新探测清理过期数据的开始下标为 i，即slotToExpunge=i 12345678for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len))&#123; if (e.get() == null)&#123; slotToExpunge = i; &#125;&#125; 接着开始从staleSlot向后查找，也是碰到Entry为null的桶结束。如果迭代过程中，碰到 k == key，这说明这里是替换逻辑，替换新数据并且交换当前staleSlot位置。如果slotToExpunge == staleSlot，这说明replaceStaleEntry()一开始向前查找过期数据时并未找到过期的Entry数据，接着向后查找过程中也未发现过期数据，修改开始探测式清理过期数据的下标为当前循环的 index，即slotToExpunge = i。最后调用cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);进行启发式过期数据清理。 123456789101112if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return;&#125; cleanSomeSlots()和expungeStaleEntry()方法后面都会细讲，这两个是和清理相关的方法，一个是过期key相关Entry的启发式清理(Heuristically scan)，另一个是过期key相关Entry的探测式清理。 如果 k != key则会接着往下走，k == null说明当前遍历的Entry是一个过期数据，slotToExpunge == staleSlot说明，一开始的向前查找数据并未找到过期的Entry。如果条件成立，则更新slotToExpunge 为当前位置，这个前提是前驱节点扫描时未发现过期数据。 12if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; 往后迭代的过程中如果没有找到k == key的数据，且碰到Entry为null的数据，则结束当前的迭代操作。此时说明这里是一个添加的逻辑，将新的数据添加到table[staleSlot] 对应的slot中。 12tab[staleSlot].value = null;tab[staleSlot] = new Entry(key, value); 最后判断除了staleSlot以外，还发现了其他过期的slot数据，就要开启清理数据的逻辑： 12if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); ThreadLocalMap过期 key 的探测式清理流程上面我们有提及ThreadLocalMap的两种过期key数据清理方式：探测式清理和启发式清理。 我们先讲下探测式清理，也就是expungeStaleEntry方法，遍历散列数组，从开始位置向后探测清理过期数据，将过期数据的Entry设置为null，沿途中碰到未过期的数据则将此数据rehash后重新在table数组中定位，如果定位的位置已经有了数据，则会将未过期的数据放到最靠近此位置的Entry=null的桶中，使rehash后的Entry数据距离正确的桶的位置更近一些。操作逻辑如下： 如上图，set(27) 经过 hash 计算后应该落到index=4的桶中，由于index=4桶已经有了数据，所以往后迭代最终数据放入到index=7的桶中，放入后一段时间后index=5中的Entry数据key变为了null 如果再有其他数据set到map中，就会触发探测式清理操作。 如上图，执行探测式清理后，index=5的数据被清理掉，继续往后迭代，到index=7的元素时，经过rehash后发现该元素正确的index=4，而此位置已经有了数据，往后查找离index=4最近的Entry=null的节点(刚被探测式清理掉的数据：index=5)，找到后移动index= 7的数据到index=5中，此时桶的位置离正确的位置index=4更近了。 经过一轮探测式清理后，key过期的数据会被清理掉，没过期的数据经过rehash重定位后所处的桶位置理论上更接近i= key.hashCode &amp; (tab.len - 1)的位置。这种优化会提高整个散列表查询性能。 接着看下expungeStaleEntry()具体流程，我们还是以先原理图后源码讲解的方式来一步步梳理： 我们假设expungeStaleEntry(3) 来调用此方法，如上图所示，我们可以看到ThreadLocalMap中table的数据情况，接着执行清理操作： 第一步是清空当前staleSlot位置的数据，index=3位置的Entry变成了null。然后接着往后探测： 执行完第二步后，index=4 的元素挪到 index=3 的槽位中。 继续往后迭代检查，碰到正常数据，计算该数据位置是否偏移，如果被偏移，则重新计算slot位置，目的是让正常数据尽可能存放在正确位置或离正确位置更近的位置 在往后迭代的过程中碰到空的槽位，终止探测，这样一轮探测式清理工作就完成了，接着我们继续看看具体实现源代码： 12345678910111213141516171819202122232425262728293031private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; tab[staleSlot].value = null; tab[staleSlot] = null; size--; Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125; 这里我们还是以staleSlot=3 来做示例说明，首先是将tab[staleSlot]槽位的数据清空，然后设置size--接着以staleSlot位置往后迭代，如果遇到k==null的过期数据，也是清空该槽位数据，然后size-- 1234567ThreadLocal&lt;?&gt; k = e.get();if (k == null) &#123; e.value = null; tab[i] = null; size--;&#125; 如果key没有过期，重新计算当前key的下标位置是不是当前槽位下标位置，如果不是，那么说明产生了hash冲突，此时以新计算出来正确的槽位位置往后迭代，找到最近一个可以存放entry的位置。 123456789int h = k.threadLocalHashCode &amp; (len - 1);if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e;&#125; 这里是处理正常的产生Hash冲突的数据，经过迭代后，有过Hash冲突数据的Entry位置会更靠近正确位置，这样的话，查询的时候 效率才会更高。 ThreadLocalMap扩容机制在ThreadLocalMap.set()方法的最后，如果执行完启发式清理工作后，未清理到任何数据，且当前散列数组中Entry的数量已经达到了列表的扩容阈值(len*2/3)，就开始执行rehash()逻辑： 12if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash(); 接着看下rehash()具体实现： 12345678910111213141516private void rehash() &#123; expungeStaleEntries(); if (size &gt;= threshold - threshold / 4) resize();&#125;private void expungeStaleEntries() &#123; Entry[] tab = table; int len = tab.length; for (int j = 0; j &lt; len; j++) &#123; Entry e = tab[j]; if (e != null &amp;&amp; e.get() == null) expungeStaleEntry(j); &#125;&#125; 这里首先是会进行探测式清理工作，从table的起始位置往后清理，上面有分析清理的详细流程。清理完成之后，table中可能有一些key为null的Entry数据被清理掉，所以此时通过判断size &gt;= threshold - threshold / 4 也就是size &gt;= threshold * 3/4 来决定是否扩容。 我们还记得上面进行rehash()的阈值是size &gt;= threshold，所以当面试官套路我们ThreadLocalMap扩容机制的时候 我们一定要说清楚这两个步骤： 接着看看具体的resize()方法，为了方便演示，我们以oldTab.len=8来举例： 扩容后的tab的大小为oldLen * 2，然后遍历老的散列表，重新计算hash位置，然后放到新的tab数组中，如果出现hash冲突则往后寻找最近的entry为null的槽位，遍历完成之后，oldTab中所有的entry数据都已经放入到新的tab中了。重新计算tab下次扩容的阈值，具体代码如下： 123456789101112131415161718192021222324252627private void resize() &#123; Entry[] oldTab = table; int oldLen = oldTab.length; int newLen = oldLen * 2; Entry[] newTab = new Entry[newLen]; int count = 0; for (int j = 0; j &lt; oldLen; ++j) &#123; Entry e = oldTab[j]; if (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == null) &#123; e.value = null; &#125; else &#123; int h = k.threadLocalHashCode &amp; (newLen - 1); while (newTab[h] != null) h = nextIndex(h, newLen); newTab[h] = e; count++; &#125; &#125; &#125; setThreshold(newLen); size = count; table = newTab;&#125; ThreadLocalMap.get()详解上面已经看完了set()方法的源码，其中包括set数据、清理数据、优化数据桶的位置等操作，接着看看get()操作的原理。 ThreadLocalMap.get()图解第一种情况： 通过查找key值计算出散列表中slot位置，然后该slot位置中的Entry.key和查找的key一致，则直接返回： 第二种情况： slot位置中的Entry.key和要查找的key不一致： 我们以get(ThreadLocal1)为例，通过hash计算后，正确的slot位置应该是 4，而index=4的槽位已经有了数据，且key值不等于ThreadLocal1，所以需要继续往后迭代查找。 迭代到index=5的数据时，此时Entry.key=null，触发一次探测式数据回收操作，执行expungeStaleEntry()方法，执行完后，index 5,8的数据都会被回收，而index 6,7的数据都会前移。index 6,7前移之后，继续从 index=5 往后迭代，于是就在 index=5 找到了key值相等的Entry数据，如下图所示： ThreadLocalMap.get()源码详解java.lang.ThreadLocal.ThreadLocalMap.getEntry(): 12345678910111213141516171819202122232425private Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;private Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125; ThreadLocalMap过期 key 的启发式清理流程上面多次提及到ThreadLocalMap过期key的两种清理方式：探测式清理(expungeStaleEntry())、启发式清理(cleanSomeSlots()) 探测式清理是以当前Entry 往后清理，遇到值为null则结束清理，属于线性探测清理。 而启发式清理被作者定义为：Heuristically scan some cells looking for stale entries. 具体代码如下： 123456789101112131415private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; n = len; removed = true; i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0); return removed;&#125; InheritableThreadLocal我们使用ThreadLocal的时候，在异步场景下是无法给子线程共享父线程中创建的线程副本数据的。 为了解决这个问题，JDK 中还有一个InheritableThreadLocal类，我们来看一个例子： 12345678910111213141516public class InheritableThreadLocalDemo &#123; public static void main(String[] args) &#123; ThreadLocal&lt;String&gt; ThreadLocal = new ThreadLocal&lt;&gt;(); ThreadLocal&lt;String&gt; inheritableThreadLocal = new InheritableThreadLocal&lt;&gt;(); ThreadLocal.set(&quot;父类数据:threadLocal&quot;); inheritableThreadLocal.set(&quot;父类数据:inheritableThreadLocal&quot;); new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;子线程获取父类ThreadLocal数据：&quot; + ThreadLocal.get()); System.out.println(&quot;子线程获取父类inheritableThreadLocal数据：&quot; + inheritableThreadLocal.get()); &#125; &#125;).start(); &#125;&#125; 打印结果： 12子线程获取父类ThreadLocal数据：null子线程获取父类inheritableThreadLocal数据：父类数据:inheritableThreadLocal 实现原理是子线程是通过在父线程中通过调用new Thread()方法来创建子线程，Thread#init方法在Thread的构造方法中被调用。在init方法中拷贝父线程数据到子线程中： 12345678910111213private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc, boolean inheritThreadLocals) &#123; if (name == null) &#123; throw new NullPointerException(&quot;name cannot be null&quot;); &#125; if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null) this.inheritableThreadLocals = ThreadLocal.createInheritedMap(parent.inheritableThreadLocals); this.stackSize = stackSize; tid = nextThreadID();&#125; 但InheritableThreadLocal仍然有缺陷，一般我们做异步化处理都是使用的线程池，而InheritableThreadLocal是在new Thread中的init()方法给赋值的，而线程池是线程复用的逻辑，所以这里会存在问题。 当然，有问题出现就会有解决问题的方案，阿里巴巴开源了一个TransmittableThreadLocal组件就可以解决这个问题，这里就不再延伸，感兴趣的可自行查阅资料。 ThreadLocal项目中使用实战ThreadLocal使用场景我们现在项目中日志记录用的是ELK+Logstash，最后在Kibana中进行展示和检索。 现在都是分布式系统统一对外提供服务，项目间调用的关系可以通过 traceId 来关联，但是不同项目之间如何传递 traceId 呢？ 这里我们使用 org.slf4j.MDC 来实现此功能，内部就是通过 ThreadLocal 来实现的，具体实现如下： 当前端发送请求到服务 A时，服务 A会生成一个类似UUID的traceId字符串，将此字符串放入当前线程的ThreadLocal中，在调用服务 B的时候，将traceId写入到请求的Header中，服务 B在接收请求时会先判断请求的Header中是否有traceId，如果存在则写入自己线程的ThreadLocal中。 图中的requestId即为我们各个系统链路关联的traceId，系统间互相调用，通过这个requestId即可找到对应链路，这里还有会有一些其他场景： 针对于这些场景，我们都可以有相应的解决方案，如下所示 Feign 远程调用解决方案服务发送请求： 123456789101112@Component@Slf4jpublic class FeignInvokeInterceptor implements RequestInterceptor &#123; @Override public void apply(RequestTemplate template) &#123; String requestId = MDC.get(&quot;requestId&quot;); if (StringUtils.isNotBlank(requestId)) &#123; template.header(&quot;requestId&quot;, requestId); &#125; &#125;&#125; 服务接收请求： 123456789101112131415161718192021222324@Slf4j@Componentpublic class LogInterceptor extends HandlerInterceptorAdapter &#123; @Override public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3) &#123; MDC.remove(&quot;requestId&quot;); &#125; @Override public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3) &#123; &#125; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; String requestId = request.getHeader(BaseConstant.REQUEST_ID_KEY); if (StringUtils.isBlank(requestId)) &#123; requestId = UUID.randomUUID().toString().replace(&quot;-&quot;, &quot;&quot;); &#125; MDC.put(&quot;requestId&quot;, requestId); return true; &#125;&#125; 线程池异步调用，requestId 传递因为MDC是基于ThreadLocal去实现的，异步过程中，子线程并没有办法获取到父线程ThreadLocal存储的数据，所以这里可以自定义线程池执行器，修改其中的run()方法： 1234567891011121314151617181920public class MyThreadPoolTaskExecutor extends ThreadPoolTaskExecutor &#123; @Override public void execute(Runnable runnable) &#123; Map&lt;String, String&gt; context = MDC.getCopyOfContextMap(); super.execute(() -&gt; run(runnable, context)); &#125; @Override private void run(Runnable runnable, Map&lt;String, String&gt; context) &#123; if (context != null) &#123; MDC.setContextMap(context); &#125; try &#123; runnable.run(); &#125; finally &#123; MDC.remove(); &#125; &#125;&#125; 使用 MQ 发送消息给第三方系统在 MQ 发送的消息体中自定义属性requestId，接收方消费消息后，自己解析requestId使用即可。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"Java 魔法类 Unsafe 详解","slug":"unsafe","date":"2024-08-07T07:58:01.147Z","updated":"2023-03-23T06:17:54.406Z","comments":true,"path":"2024/08/07/unsafe/","link":"","permalink":"http://example.com/2024/08/07/unsafe/","excerpt":"","text":"本文整理完善自下面这两篇优秀的文章： Java魔法类：Unsafe 应用解析 - 美团技术团队 -2019 Java 双刃剑之 Unsafe 类详解 - 码农参上 - 2021 阅读过 JUC 源码的同学，一定会发现很多并发工具类都调用了一个叫做 Unsafe 的类。 那这个类主要是用来干什么的呢？有什么使用场景呢？这篇文章就带你搞清楚！ Unsafe 介绍Unsafe 是位于 sun.misc 包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升 Java 运行效率、增强 Java 语言底层资源操作能力方面起到了很大的作用。但由于 Unsafe 类使 Java 语言拥有了类似 C 语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。在程序中过度、不正确使用 Unsafe 类会使得程序出错的概率变大，使得 Java 这种安全的语言变得不再“安全”，因此对 Unsafe 的使用一定要慎重。 另外，Unsafe 提供的这些功能的实现需要依赖本地方法（Native Method）。你可以将本地方法看作是 Java 中使用其他编程语言编写的方法。本地方法使用 native 关键字修饰，Java 代码中只是声明方法头，具体的实现则交给 本地代码。 为什么要使用本地方法呢？ 需要用到 Java 中不具备的依赖于操作系统的特性，Java 在实现跨平台的同时要实现对底层的控制，需要借助其他语言发挥作用。 对于其他语言已经完成的一些现成功能，可以使用 Java 直接调用。 程序对时间敏感或对性能要求非常高时，有必要使用更加底层的语言，例如 C/C++甚至是汇编。 在 JUC 包的很多并发工具类在实现并发机制时，都调用了本地方法，通过它们打破了 Java 运行时的界限，能够接触到操作系统底层的某些功能。对于同一本地方法，不同的操作系统可能会通过不同的方式来实现，但是对于使用者来说是透明的，最终都会得到相同的结果。 Unsafe 创建sun.misc.Unsafe 部分源码如下： 1234567891011121314151617public final class Unsafe &#123; // 单例对象 private static final Unsafe theUnsafe; ...... private Unsafe() &#123; &#125; @CallerSensitive public static Unsafe getUnsafe() &#123; Class var0 = Reflection.getCallerClass(); // 仅在引导类加载器`BootstrapClassLoader`加载时才合法 if(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(&quot;Unsafe&quot;); &#125; else &#123; return theUnsafe; &#125; &#125;&#125; Unsafe 类为一单例实现，提供静态方法 getUnsafe 获取 Unsafe实例。这个看上去貌似可以用来获取 Unsafe 实例。但是，当我们直接调用这个静态方法的时候，会抛出 SecurityException 异常： 123Exception in thread &quot;main&quot; java.lang.SecurityException: Unsafe at sun.misc.Unsafe.getUnsafe(Unsafe.java:90) at com.cn.test.GetUnsafeTest.main(GetUnsafeTest.java:12) 为什么 public static 方法无法被直接调用呢？ 这是因为在getUnsafe方法中，会对调用者的classLoader进行检查，判断当前类是否由Bootstrap classLoader加载，如果不是的话那么就会抛出一个SecurityException异常。也就是说，只有启动类加载器加载的类才能够调用 Unsafe 类中的方法，来防止这些方法在不可信的代码中被调用。 为什么要对 Unsafe 类进行这么谨慎的使用限制呢? Unsafe 提供的功能过于底层（如直接访问系统内存资源、自主管理内存资源等），安全隐患也比较大，使用不当的话，很容易出现很严重的问题。 如若想使用 Unsafe 这个类的话，应该如何获取其实例呢？ 这里介绍两个可行的方案。 1、利用反射获得 Unsafe 类中已经实例化完成的单例对象 theUnsafe 。 12345678910private static Unsafe reflectGetUnsafe() &#123; try &#123; Field field = Unsafe.class.getDeclaredField(&quot;theUnsafe&quot;); field.setAccessible(true); return (Unsafe) field.get(null); &#125; catch (Exception e) &#123; log.error(e.getMessage(), e); return null; &#125;&#125; 2、从getUnsafe方法的使用限制条件出发，通过 Java 命令行命令-Xbootclasspath/a把调用 Unsafe 相关方法的类 A 所在 jar 包路径追加到默认的 bootstrap 路径中，使得 A 被引导类加载器加载，从而通过Unsafe.getUnsafe方法安全的获取 Unsafe 实例。 1java -Xbootclasspath/a: $&#123;path&#125; // 其中path为调用Unsafe相关方法的类所在jar包路径 Unsafe 功能概括的来说，Unsafe 类实现功能可以被分为下面 8 类： 内存操作 内存屏障 对象操作 数据操作 CAS 操作 线程调度 Class 操作 系统信息 内存操作介绍如果你是一个写过 C 或者 C++ 的程序员，一定对内存操作不会陌生，而在 Java 中是不允许直接对内存进行操作的，对象内存的分配和回收都是由 JVM 自己实现的。但是在 Unsafe 中，提供的下列接口可以直接进行内存操作： 12345678910//分配新的本地空间public native long allocateMemory(long bytes);//重新调整内存空间的大小public native long reallocateMemory(long address, long bytes);//将内存设置为指定值public native void setMemory(Object o, long offset, long bytes, byte value);//内存拷贝public native void copyMemory(Object srcBase, long srcOffset,Object destBase, long destOffset,long bytes);//清除内存public native void freeMemory(long address); 使用下面的代码进行测试： 123456789101112131415161718private void memoryTest() &#123; int size = 4; long addr = unsafe.allocateMemory(size); long addr3 = unsafe.reallocateMemory(addr, size * 2); System.out.println(&quot;addr: &quot;+addr); System.out.println(&quot;addr3: &quot;+addr3); try &#123; unsafe.setMemory(null,addr ,size,(byte)1); for (int i = 0; i &lt; 2; i++) &#123; unsafe.copyMemory(null,addr,null,addr3+size*i,4); &#125; System.out.println(unsafe.getInt(addr)); System.out.println(unsafe.getLong(addr3)); &#125;finally &#123; unsafe.freeMemory(addr); unsafe.freeMemory(addr3); &#125;&#125; 先看结果输出： 1234addr: 2433733895744addr3: 24337338949441684300972340172838076673 分析一下运行结果，首先使用allocateMemory方法申请 4 字节长度的内存空间，调用setMemory方法向每个字节写入内容为byte类型的 1，当使用 Unsafe 调用getInt方法时，因为一个int型变量占 4 个字节，会一次性读取 4 个字节，组成一个int的值，对应的十进制结果为 16843009。 你可以通过下图理解这个过程： 在代码中调用reallocateMemory方法重新分配了一块 8 字节长度的内存空间，通过比较addr和addr3可以看到和之前申请的内存地址是不同的。在代码中的第二个 for 循环里，调用copyMemory方法进行了两次内存的拷贝，每次拷贝内存地址addr开始的 4 个字节，分别拷贝到以addr3和addr3+4开始的内存空间上： 拷贝完成后，使用getLong方法一次性读取 8 个字节，得到long类型的值为 72340172838076673。 需要注意，通过这种方式分配的内存属于 堆外内存 ，是无法进行垃圾回收的，需要我们把这些内存当做一种资源去手动调用freeMemory方法进行释放，否则会产生内存泄漏。通用的操作内存方式是在try中执行对内存的操作，最终在finally块中进行内存的释放。 为什么要使用堆外内存？ 对垃圾回收停顿的改善。由于堆外内存是直接受操作系统管理而不是 JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在 GC 时减少回收停顿对于应用的影响。 提升程序 I/O 操作的性能。通常在 I/O 通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。 典型应用DirectByteBuffer 是 Java 用于实现堆外内存的一个重要类，通常用在通信过程中做缓冲池，如在 Netty、MINA 等 NIO 框架中应用广泛。DirectByteBuffer 对于堆外内存的创建、使用、销毁等逻辑均由 Unsafe 提供的堆外内存 API 来实现。 下图为 DirectByteBuffer 构造函数，创建 DirectByteBuffer 的时候，通过 Unsafe.allocateMemory 分配内存、Unsafe.setMemory 进行内存初始化，而后构建 Cleaner 对象用于跟踪 DirectByteBuffer 对象的垃圾回收，以实现当 DirectByteBuffer 被垃圾回收时，分配的堆外内存一起被释放。 12345678910111213141516171819202122232425262728DirectByteBuffer(int cap) &#123; // package-private super(-1, 0, cap, cap); boolean pa = VM.isDirectMemoryPageAligned(); int ps = Bits.pageSize(); long size = Math.max(1L, (long)cap + (pa ? ps : 0)); Bits.reserveMemory(size, cap); long base = 0; try &#123; // 分配内存并返回基地址 base = unsafe.allocateMemory(size); &#125; catch (OutOfMemoryError x) &#123; Bits.unreserveMemory(size, cap); throw x; &#125; // 内存初始化 unsafe.setMemory(base, size, (byte) 0); if (pa &amp;&amp; (base % ps != 0)) &#123; // Round up to page boundary address = base + ps - (base &amp; (ps - 1)); &#125; else &#123; address = base; &#125; // 跟踪 DirectByteBuffer 对象的垃圾回收，以实现堆外内存释放 cleaner = Cleaner.create(this, new Deallocator(base, size, cap)); att = null;&#125; 内存屏障介绍在介绍内存屏障前，需要知道编译器和 CPU 会在保证程序输出结果一致的情况下，会对代码进行重排序，从指令优化角度提升性能。而指令重排序可能会带来一个不好的结果，导致 CPU 的高速缓存和内存中数据的不一致，而内存屏障（Memory Barrier）就是通过阻止屏障两边的指令重排序从而避免编译器和硬件的不正确优化情况。 在硬件层面上，内存屏障是 CPU 为了防止代码进行重排序而提供的指令，不同的硬件平台上实现内存屏障的方法可能并不相同。在 Java8 中，引入了 3 个内存屏障的函数，它屏蔽了操作系统底层的差异，允许在代码中定义、并统一由 JVM 来生成内存屏障指令，来实现内存屏障的功能。 Unsafe 中提供了下面三个内存屏障相关方法： 123456//内存屏障，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前public native void loadFence();//内存屏障，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后，屏障后的store操作不能被重排序到屏障前public native void storeFence();//内存屏障，禁止load、store操作重排序public native void fullFence(); 内存屏障可以看做对内存随机访问的操作中的一个同步点，使得此点之前的所有读写操作都执行后才可以开始执行此点之后的操作。以loadFence方法为例，它会禁止读操作重排序，保证在这个屏障之前的所有读操作都已经完成，并且将缓存数据设为无效，重新从主存中进行加载。 看到这估计很多小伙伴们会想到volatile关键字了，如果在字段上添加了volatile关键字，就能够实现字段在多线程下的可见性。基于读内存屏障，我们也能实现相同的功能。下面定义一个线程方法，在线程中去修改flag标志位，注意这里的flag是没有被volatile修饰的： 1234567891011121314@Getterclass ChangeThread implements Runnable&#123; /**volatile**/ boolean flag=false; @Override public void run() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;subThread change flag to:&quot; + flag); flag = true; &#125;&#125; 在主线程的while循环中，加入内存屏障，测试是否能够感知到flag的修改变化： 12345678910111213public static void main(String[] args)&#123; ChangeThread changeThread = new ChangeThread(); new Thread(changeThread).start(); while (true) &#123; boolean flag = changeThread.isFlag(); unsafe.loadFence(); //加入读内存屏障 if (flag)&#123; System.out.println(&quot;detected flag changed&quot;); break; &#125; &#125; System.out.println(&quot;main thread end&quot;);&#125; 运行结果： 123subThread change flag to:falsedetected flag changedmain thread end 而如果删掉上面代码中的loadFence方法，那么主线程将无法感知到flag发生的变化，会一直在while中循环。可以用图来表示上面的过程： 了解 Java 内存模型（JMM）的小伙伴们应该清楚，运行中的线程不是直接读取主内存中的变量的，只能操作自己工作内存中的变量，然后同步到主内存中，并且线程的工作内存是不能共享的。上面的图中的流程就是子线程借助于主内存，将修改后的结果同步给了主线程，进而修改主线程中的工作空间，跳出循环。 典型应用在 Java 8 中引入了一种锁的新机制——StampedLock，它可以看成是读写锁的一个改进版本。StampedLock 提供了一种乐观读锁的实现，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象。由于 StampedLock 提供的乐观读锁不阻塞写线程获取读锁，当线程共享变量从主内存 load 到线程工作内存时，会存在数据不一致问题。 为了解决这个问题，StampedLock 的 validate 方法会通过 Unsafe 的 loadFence 方法加入一个 load 内存屏障。 1234public boolean validate(long stamp) &#123; U.loadFence(); return (stamp &amp; SBITS) == (state &amp; SBITS);&#125; 对象操作介绍对象属性 对象成员属性的内存偏移量获取，以及字段属性值的修改，在上面的例子中我们已经测试过了。除了前面的putInt、getInt方法外，Unsafe 提供了全部 8 种基础数据类型以及Object的put和get方法，并且所有的put方法都可以越过访问权限，直接修改内存中的数据。阅读 openJDK 源码中的注释发现，基础数据类型和Object的读写稍有不同，基础数据类型是直接操作的属性值（value），而Object的操作则是基于引用值（reference value）。下面是Object的读写方法： 1234//在对象的指定偏移地址获取一个对象引用public native Object getObject(Object o, long offset);//在对象指定偏移地址写入一个对象引用public native void putObject(Object o, long offset, Object x); 除了对象属性的普通读写外，Unsafe 还提供了 volatile 读写和有序写入方法。volatile读写方法的覆盖范围与普通读写相同，包含了全部基础数据类型和Object类型，以int类型为例： 1234//在对象的指定偏移地址处读取一个int值，支持volatile load语义public native int getIntVolatile(Object o, long offset);//在对象指定偏移地址处写入一个int，支持volatile store语义public native void putIntVolatile(Object o, long offset, int x); 相对于普通读写来说，volatile读写具有更高的成本，因为它需要保证可见性和有序性。在执行get操作时，会强制从主存中获取属性值，在使用put方法设置属性值时，会强制将值更新到主存中，从而保证这些变更对其他线程是可见的。 有序写入的方法有以下三个： 123public native void putOrderedObject(Object o, long offset, Object x);public native void putOrderedInt(Object o, long offset, int x);public native void putOrderedLong(Object o, long offset, long x); 有序写入的成本相对volatile较低，因为它只保证写入时的有序性，而不保证可见性，也就是一个线程写入的值不能保证其他线程立即可见。为了解决这里的差异性，需要对内存屏障的知识点再进一步进行补充，首先需要了解两个指令的概念： Load：将主内存中的数据拷贝到处理器的缓存中 Store：将处理器缓存的数据刷新到主内存中 顺序写入与volatile写入的差别在于，在顺序写时加入的内存屏障类型为StoreStore类型，而在volatile写入时加入的内存屏障是StoreLoad类型，如下图所示： 在有序写入方法中，使用的是StoreStore屏障，该屏障确保Store1立刻刷新数据到内存，这一操作先于Store2以及后续的存储指令操作。而在volatile写入中，使用的是StoreLoad屏障，该屏障确保Store1立刻刷新数据到内存，这一操作先于Load2及后续的装载指令，并且，StoreLoad屏障会使该屏障之前的所有内存访问指令，包括存储指令和访问指令全部完成之后，才执行该屏障之后的内存访问指令。 综上所述，在上面的三类写入方法中，在写入效率方面，按照put、putOrder、putVolatile的顺序效率逐渐降低。 对象实例化 使用 Unsafe 的 allocateInstance 方法，允许我们使用非常规的方式进行对象的实例化，首先定义一个实体类，并且在构造函数中对其成员变量进行赋值操作： 1234567@Datapublic class A &#123; private int b; public A()&#123; this.b =1; &#125;&#125; 分别基于构造函数、反射以及 Unsafe 方法的不同方式创建对象进行比较： 12345678public void objTest() throws Exception&#123; A a1=new A(); System.out.println(a1.getB()); A a2 = A.class.newInstance(); System.out.println(a2.getB()); A a3= (A) unsafe.allocateInstance(A.class); System.out.println(a3.getB());&#125; 打印结果分别为 1、1、0，说明通过allocateInstance方法创建对象过程中，不会调用类的构造方法。使用这种方式创建对象时，只用到了Class对象，所以说如果想要跳过对象的初始化阶段或者跳过构造器的安全检查，就可以使用这种方法。在上面的例子中，如果将 A 类的构造函数改为private类型，将无法通过构造函数和反射创建对象，但allocateInstance方法仍然有效。 典型应用 常规对象实例化方式：我们通常所用到的创建对象的方式，从本质上来讲，都是通过 new 机制来实现对象的创建。但是，new 机制有个特点就是当类只提供有参的构造函数且无显示声明无参构造函数时，则必须使用有参构造函数进行对象构造，而使用有参构造函数时，必须传递相应个数的参数才能完成对象实例化。 非常规的实例化方式：而 Unsafe 中提供 allocateInstance 方法，仅通过 Class 对象就可以创建此类的实例对象，而且不需要调用其构造函数、初始化代码、JVM 安全检查等。它抑制修饰符检测，也就是即使构造器是 private 修饰的也能通过此方法实例化，只需提类对象即可创建相应的对象。由于这种特性，allocateInstance 在 java.lang.invoke、Objenesis（提供绕过类构造器的对象生成方式）、Gson（反序列化时用到）中都有相应的应用。 数组操作介绍arrayBaseOffset 与 arrayIndexScale 这两个方法配合起来使用，即可定位数组中每个元素在内存中的位置。 1234//返回数组中第一个元素的偏移地址public native int arrayBaseOffset(Class&lt;?&gt; arrayClass);//返回数组中一个元素占用的大小public native int arrayIndexScale(Class&lt;?&gt; arrayClass); 典型应用这两个与数据操作相关的方法，在 java.util.concurrent.atomic 包下的 AtomicIntegerArray（可以实现对 Integer 数组中每个元素的原子性操作）中有典型的应用，如下图 AtomicIntegerArray 源码所示，通过 Unsafe 的 arrayBaseOffset 、arrayIndexScale 分别获取数组首元素的偏移地址 base 及单个元素大小因子 scale 。后续相关原子性操作，均依赖于这两个值进行数组中元素的定位，如下图二所示的 getAndAdd 方法即通过 checkedByteOffset 方法获取某数组元素的偏移地址，而后通过 CAS 实现原子性操作。 CAS 操作介绍这部分主要为 CAS 相关操作的方法。 12345678910111213/** * CAS * @param o 包含要修改field的对象 * @param offset 对象中某field的偏移量 * @param expected 期望值 * @param update 更新值 * @return true | false */public final native boolean compareAndSwapObject(Object o, long offset, Object expected, Object update);public final native boolean compareAndSwapInt(Object o, long offset, int expected,int update);public final native boolean compareAndSwapLong(Object o, long offset, long expected, long update); 什么是 CAS? CAS 即比较并替换（Compare And Swap)，是实现并发算法时常用到的一种技术。CAS 操作包含三个操作数——内存位置、预期原值及新值。执行 CAS 操作的时候，将内存位置的值与预期原值比较，如果相匹配，那么处理器会自动将该位置值更新为新值，否则，处理器不做任何操作。我们都知道，CAS 是一条 CPU 的原子指令（cmpxchg 指令），不会造成所谓的数据不一致问题，Unsafe 提供的 CAS 方法（如 compareAndSwapXXX）底层实现即为 CPU 指令 cmpxchg 。 典型应用在 JUC 包的并发工具类中大量地使用了 CAS 操作，像在前面介绍synchronized和AQS的文章中也多次提到了 CAS，其作为乐观锁在并发工具类中广泛发挥了作用。在 Unsafe 类中，提供了compareAndSwapObject、compareAndSwapInt、compareAndSwapLong方法来实现的对Object、int、long类型的 CAS 操作。以compareAndSwapInt方法为例： 1public final native boolean compareAndSwapInt(Object o, long offset,int expected,int x); 参数中o为需要更新的对象，offset是对象o中整形字段的偏移量，如果这个字段的值与expected相同，则将字段的值设为x这个新值，并且此更新是不可被中断的，也就是一个原子操作。下面是一个使用compareAndSwapInt的例子： 12345678910111213141516171819202122232425262728private volatile int a;public static void main(String[] args)&#123; CasTest casTest=new CasTest(); new Thread(()-&gt;&#123; for (int i = 1; i &lt; 5; i++) &#123; casTest.increment(i); System.out.print(casTest.a+&quot; &quot;); &#125; &#125;).start(); new Thread(()-&gt;&#123; for (int i = 5 ; i &lt;10 ; i++) &#123; casTest.increment(i); System.out.print(casTest.a+&quot; &quot;); &#125; &#125;).start();&#125;private void increment(int x)&#123; while (true)&#123; try &#123; long fieldOffset = unsafe.objectFieldOffset(CasTest.class.getDeclaredField(&quot;a&quot;)); if (unsafe.compareAndSwapInt(this,fieldOffset,x-1,x)) break; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行代码会依次输出： 11 2 3 4 5 6 7 8 9 在上面的例子中，使用两个线程去修改int型属性a的值，并且只有在a的值等于传入的参数x减一时，才会将a的值变为x，也就是实现对a的加一的操作。流程如下所示： 需要注意的是，在调用compareAndSwapInt方法后，会直接返回true或false的修改结果，因此需要我们在代码中手动添加自旋的逻辑。在AtomicInteger类的设计中，也是采用了将compareAndSwapInt的结果作为循环条件，直至修改成功才退出死循环的方式来实现的原子性的自增操作。 线程调度介绍Unsafe 类中提供了park、unpark、monitorEnter、monitorExit、tryMonitorEnter方法进行线程调度。 12345678910111213//取消阻塞线程public native void unpark(Object thread);//阻塞线程public native void park(boolean isAbsolute, long time);//获得对象锁（可重入锁）@Deprecatedpublic native void monitorEnter(Object o);//释放对象锁@Deprecatedpublic native void monitorExit(Object o);//尝试获取对象锁@Deprecatedpublic native boolean tryMonitorEnter(Object o); 方法 park、unpark 即可实现线程的挂起与恢复，将一个线程进行挂起是通过 park 方法实现的，调用 park 方法后，线程将一直阻塞直到超时或者中断等条件出现；unpark 可以终止一个挂起的线程，使其恢复正常。 此外，Unsafe 源码中monitor相关的三个方法已经被标记为deprecated，不建议被使用： 123456789//获得对象锁@Deprecatedpublic native void monitorEnter(Object var1);//释放对象锁@Deprecatedpublic native void monitorExit(Object var1);//尝试获得对象锁@Deprecatedpublic native boolean tryMonitorEnter(Object var1); monitorEnter方法用于获得对象锁，monitorExit用于释放对象锁，如果对一个没有被monitorEnter加锁的对象执行此方法，会抛出IllegalMonitorStateException异常。tryMonitorEnter方法尝试获取对象锁，如果成功则返回true，反之返回false。 典型应用Java 锁和同步器框架的核心类 AbstractQueuedSynchronizer (AQS)，就是通过调用LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而 LockSupport 的 park 、unpark 方法实际是调用 Unsafe 的 park 、unpark 方式实现的。 12345678910public static void park(Object blocker) &#123; Thread t = Thread.currentThread(); setBlocker(t, blocker); UNSAFE.park(false, 0L); setBlocker(t, null);&#125;public static void unpark(Thread thread) &#123; if (thread != null) UNSAFE.unpark(thread);&#125; LockSupport 的park方法调用了 Unsafe 的park方法来阻塞当前线程，此方法将线程阻塞后就不会继续往后执行，直到有其他线程调用unpark方法唤醒当前线程。下面的例子对 Unsafe 的这两个方法进行测试： 12345678910111213141516public static void main(String[] args) &#123; Thread mainThread = Thread.currentThread(); new Thread(()-&gt;&#123; try &#123; TimeUnit.SECONDS.sleep(5); System.out.println(&quot;subThread try to unpark mainThread&quot;); unsafe.unpark(mainThread); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); System.out.println(&quot;park main mainThread&quot;); unsafe.park(false,0L); System.out.println(&quot;unpark mainThread success&quot;);&#125; 程序输出为： 123park main mainThreadsubThread try to unpark mainThreadunpark mainThread success 程序运行的流程也比较容易看懂，子线程开始运行后先进行睡眠，确保主线程能够调用park方法阻塞自己，子线程在睡眠 5 秒后，调用unpark方法唤醒主线程，使主线程能继续向下执行。整个流程如下图所示： Class 操作介绍Unsafe 对Class的相关操作主要包括类加载和静态变量的操作方法。 静态属性读取相关的方法 123456//获取静态属性的偏移量public native long staticFieldOffset(Field f);//获取静态属性的对象指针public native Object staticFieldBase(Field f);//判断类是否需要实例化（用于获取类的静态属性前进行检测）public native boolean shouldBeInitialized(Class&lt;?&gt; c); 创建一个包含静态属性的类，进行测试： 1234567891011121314@Datapublic class User &#123; public static String name=&quot;Hydra&quot;; int age;&#125;private void staticTest() throws Exception &#123; User user=new User(); System.out.println(unsafe.shouldBeInitialized(User.class)); Field sexField = User.class.getDeclaredField(&quot;name&quot;); long fieldOffset = unsafe.staticFieldOffset(sexField); Object fieldBase = unsafe.staticFieldBase(sexField); Object object = unsafe.getObject(fieldBase, fieldOffset); System.out.println(object);&#125; 运行结果： 1falseHydra 在 Unsafe 的对象操作中，我们学习了通过objectFieldOffset方法获取对象属性偏移量并基于它对变量的值进行存取，但是它不适用于类中的静态属性，这时候就需要使用staticFieldOffset方法。在上面的代码中，只有在获取Field对象的过程中依赖到了Class，而获取静态变量的属性时不再依赖于Class。 在上面的代码中首先创建一个User对象，这是因为如果一个类没有被实例化，那么它的静态属性也不会被初始化，最后获取的字段属性将是null。所以在获取静态属性前，需要调用shouldBeInitialized方法，判断在获取前是否需要初始化这个类。如果删除创建 User 对象的语句，运行结果会变为： 1truenull 使用defineClass方法允许程序在运行时动态地创建一个类 1public native Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len, ClassLoader loader,ProtectionDomain protectionDomain); 在实际使用过程中，可以只传入字节数组、起始字节的下标以及读取的字节长度，默认情况下，类加载器（ClassLoader）和保护域（ProtectionDomain）来源于调用此方法的实例。下面的例子中实现了反编译生成后的 class 文件的功能： 1234567891011121314private static void defineTest() &#123; String fileName=&quot;F:\\\\workspace\\\\unsafe-test\\\\target\\\\classes\\\\com\\\\cn\\\\model\\\\User.class&quot;; File file = new File(fileName); try(FileInputStream fis = new FileInputStream(file)) &#123; byte[] content=new byte[(int)file.length()]; fis.read(content); Class clazz = unsafe.defineClass(null, content, 0, content.length, null, null); Object o = clazz.newInstance(); Object age = clazz.getMethod(&quot;getAge&quot;).invoke(o, null); System.out.println(age); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 在上面的代码中，首先读取了一个class文件并通过文件流将它转化为字节数组，之后使用defineClass方法动态的创建了一个类，并在后续完成了它的实例化工作，流程如下图所示，并且通过这种方式创建的类，会跳过 JVM 的所有安全检查。 除了defineClass方法外，Unsafe 还提供了一个defineAnonymousClass方法： 1public native Class&lt;?&gt; defineAnonymousClass(Class&lt;?&gt; hostClass, byte[] data, Object[] cpPatches); 使用该方法可以用来动态的创建一个匿名类，在Lambda表达式中就是使用 ASM 动态生成字节码，然后利用该方法定义实现相应的函数式接口的匿名类。在 JDK 15 发布的新特性中，在隐藏类（Hidden classes）一条中，指出将在未来的版本中弃用 Unsafe 的defineAnonymousClass方法。 典型应用Lambda 表达式实现需要依赖 Unsafe 的 defineAnonymousClass 方法定义实现相应的函数式接口的匿名类。 系统信息介绍这部分包含两个获取系统相关信息的方法。 1234//返回系统指针的大小。返回值为4（32位系统）或 8（64位系统）。public native int addressSize();//内存页的大小，此值为2的幂次方。public native int pageSize(); 典型应用这两个方法的应用场景比较少，在java.nio.Bits类中，在使用pageCount计算所需的内存页的数量时，调用了pageSize方法获取内存页的大小。另外，在使用copySwapMemory方法拷贝内存时，调用了addressSize方法，检测 32 位系统的情况。 总结在本文中，我们首先介绍了 Unsafe 的基本概念、工作原理，并在此基础上，对它的 API 进行了说明与实践。相信大家通过这一过程，能够发现 Unsafe 在某些场景下，确实能够为我们提供编程中的便利。但是回到开头的话题，在使用这些便利时，确实存在着一些安全上的隐患，在我看来，一项技术具有不安全因素并不可怕，可怕的是它在使用过程中被滥用。尽管之前有传言说会在 Java9 中移除 Unsafe 类，不过它还是照样已经存活到了 Java16。按照存在即合理的逻辑，只要使用得当，它还是能给我们带来不少的帮助，因此最后还是建议大家，在使用 Unsafe 的过程中一定要做到使用谨慎使用、避免滥用。","categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"折叠","slug":"折叠","date":"2021-09-24T06:10:27.000Z","updated":"2021-09-24T06:44:27.000Z","comments":true,"path":"2021/09/24/折叠/","link":"","permalink":"http://example.com/2021/09/24/%E6%8A%98%E5%8F%A0/","excerpt":"","text":"相关截图: 1234if (!ParamUtil.isEmail(assessEmail)) &#123; log.warn(&quot;邮箱格式错误。邮箱: &#123;&#125;&quot;, assessEmail); throw new InvalidArgumentException(&quot;邮箱格式错误：&quot; + assessEmail); &#125; 查看图片测试 查看默认打开的折叠框 这是一个默认打开的折叠框。 查看代码测试 查看分栏测试 栏目1栏目2。。。！！！ 查看嵌套测试 查看嵌套测试2 查看嵌套测试3 hahaha","categories":[],"tags":[]},{"title":"Java泛型","slug":"Java泛型","date":"2021-09-23T07:24:46.000Z","updated":"2021-09-23T08:37:08.000Z","comments":true,"path":"2021/09/23/Java泛型/","link":"","permalink":"http://example.com/2021/09/23/Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"1. 概述泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。 什么是泛型？为什么要使用泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 2. 一个栗子一个被举了无数次的例子： 12345678List arrayList = new ArrayList();arrayList.add(&quot;aaaa&quot;);arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); Log.d(&quot;泛型测试&quot;,&quot;item = &quot; + item);&#125; 毫无疑问，程序的运行结果会以崩溃结束： 1java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 3. 特性泛型只在编译阶段有效。看下面的代码： 123456789List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;();List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;();Class classStringArrayList = stringArrayList.getClass();Class classIntegerArrayList = integerArrayList.getClass();if(classStringArrayList.equals(classIntegerArrayList))&#123; Log.d(&quot;泛型测试&quot;,&quot;类型相同&quot;);&#125; 输出结果：D/泛型测试: 类型相同。 通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 4. 泛型的使用泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 4.1 泛型类泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）： 123456class 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;&#123; private 泛型标识 /*（成员变量类型）*/ var; ..... &#125;&#125; 一个最普通的泛型类： 1234567891011121314//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型//在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt;&#123; //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) &#123; //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; &#125; public T getKey()&#123; //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; &#125;&#125; 12345678//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型//传入的实参类型需与泛型的类型参数类型相同，即为Integer.Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456);//传入的实参类型需与泛型的类型参数类型相同，即为String.Generic&lt;String&gt; genericString = new Generic&lt;String&gt;(&quot;key_vlaue&quot;);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericInteger.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + genericString.getKey()); 1212-27 09:20:04.432 13063-13063/? D/泛型测试: key is 12345612-27 09:20:04.432 13063-13063/? D/泛型测试: key is key_vlaue 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 看一个例子： 123456789Generic generic = new Generic(&quot;111111&quot;);Generic generic1 = new Generic(4444);Generic generic2 = new Generic(55.55);Generic generic3 = new Generic(false);Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic1.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic2.getKey());Log.d(&quot;泛型测试&quot;,&quot;key is &quot; + generic3.getKey()); 1234D/泛型测试: key is 111111D/泛型测试: key is 4444D/泛型测试: key is 55.55D/泛型测试: key is false 注意： 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 if(ex_num instanceof Generic){ } 4.2 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子： 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，未传入泛型实参时： 1234567891011/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错：&quot;Unknown class&quot; */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125; 当实现泛型接口的类，传入泛型实参时： 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;&quot;Apple&quot;, &quot;Banana&quot;, &quot;Pear&quot;&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 4.3 泛型通配符我们知道Ingeter是Number的一个子类，同时在特性章节中我们也验证过Generic&lt;Ingeter&gt;与Generic&lt;Number&gt;实际上是相同的一种基本类型。那么问题来了，在使用Generic&lt;Number&gt;作为形参的方法中，能否使用Generic&lt;Ingeter&gt;的实例传入呢？在逻辑上类似于Generic&lt;Number&gt;和Generic&lt;Ingeter&gt;是否可以看成具有父子关系的泛型类型呢？ 为了弄清楚这个问题，我们使用Generic&lt;T&gt;这个泛型类继续看下面的例子： 123public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 12345678Generic&lt;Integer&gt; gInteger = new Generic&lt;Integer&gt;(123);Generic&lt;Number&gt; gNumber = new Generic&lt;Number&gt;(456);showKeyValue(gNumber);// showKeyValue这个方法编译器会为我们报错：Generic&lt;java.lang.Integer&gt; // cannot be applied to Generic&lt;java.lang.Number&gt;// showKeyValue(gInteger); 通过提示信息我们可以看到Generic&lt;Integer&gt;不能被看作为``Generic`的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 回到上面的例子，如何解决上面的问题？总不能为了定义一个新的方法来处理Generic&lt;Integer&gt;类型的类，这显然与java中的多台理念相违背。因此我们需要一个在逻辑上可以表示同时是Generic&lt;Integer&gt;和Generic&lt;Number&gt;父类的引用类型。由此类型通配符应运而生。 我们可以将上面的方法改一下： 123public void showKeyValue1(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 类型通配符一般是使用？代替具体的类型实参，注意了，此处’？’是类型实参，而不是类型形参 。重要说三遍！此处’？’是类型实参，而不是类型形参 ！ 此处’？’是类型实参，而不是类型形参 ！再直白点的意思就是，此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。是一种真实的类型。 可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 4.4 泛型方法在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。 1尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。 123456789101112131415/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass)throws InstantiationException , IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125; 1Object obj = genericMethod(Class.forName(&quot;com.test.test&quot;)); 4.4.1 泛型方法的基本用法光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public class GenericTest &#123; //这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息&quot;cannot reslove symbol E&quot; * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。 public void showKeyValue1(Generic&lt;Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic&lt;?&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey()); &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;E&#x27; &quot; * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123; ... &#125; */ /** * 这个方法也是有问题的，编译器会为我们提示错误信息：&quot;UnKnown class &#x27;T&#x27; &quot; * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。 * 所以这也不是一个正确的泛型方法声明。 public void showkey(T genericObj)&#123; &#125; */ public static void main(String[] args) &#123; &#125;&#125; 4.4.2 类中的泛型方法当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GenericFruit &#123; class Fruit&#123; @Override public String toString() &#123; return &quot;fruit&quot;; &#125; &#125; class Apple extends Fruit&#123; @Override public String toString() &#123; return &quot;apple&quot;; &#125; &#125; class Person&#123; @Override public String toString() &#123; return &quot;Person&quot;; &#125; &#125; class GenerateTest&lt;T&gt;&#123; public void show_1(T t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。 //由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t)&#123; System.out.println(t.toString()); &#125; //在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。 public &lt;T&gt; void show_2(T t)&#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Apple(); Person person = new Person(); GenerateTest&lt;Fruit&gt; generateTest = new GenerateTest&lt;Fruit&gt;(); //apple是Fruit的子类，所以这里可以 generateTest.show_1(apple); //编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person //generateTest.show_1(person); //使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); //使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125; 4.4.3 泛型方法与可变参数再看一个泛型方法和可变参数的例子： 123456public &lt;T&gt; void printMsg( T... args)&#123; for(T t : args)&#123; Log.d(&quot;泛型测试&quot;,&quot;t is &quot; + t); &#125;&#125;printMsg(&quot;111&quot;,222,&quot;aaaa&quot;,&quot;2323.4&quot;,55.55); 4.4.4 静态方法与泛型静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 即：如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法 。 12345678910111213public class StaticGenerator&lt;T&gt; &#123; .... .... /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： &quot;StaticGenerator cannot be refrenced from static context&quot; */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125; 4.4.5 泛型方法总结泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则： 12345无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。 4.5 泛型上下边界在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型添加上边界，即传入的类型实参必须是指定类型的子类型 123public void showKeyValue1(Generic&lt;? extends Number&gt; obj)&#123; Log.d(&quot;泛型测试&quot;,&quot;key value is &quot; + obj.getKey());&#125; 1234567891011Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;);Generic&lt;Integer&gt; generic2 = new Generic&lt;Integer&gt;(2222);Generic&lt;Float&gt; generic3 = new Generic&lt;Float&gt;(2.4f);Generic&lt;Double&gt; generic4 = new Generic&lt;Double&gt;(2.56);//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类//showKeyValue1(generic1);showKeyValue1(generic2);showKeyValue1(generic3);showKeyValue1(generic4); 如果我们把泛型类的定义也改一下: 1234567891011public class Generic&lt;T extends Number&gt;&#123; private T key; public Generic(T key) &#123; this.key = key; &#125; public T getKey()&#123; return key; &#125; 12//这一行代码也会报错，因为String不是Number的子类Generic&lt;String&gt; generic1 = new Generic&lt;String&gt;(&quot;11111&quot;); 再来一个泛型方法的例子： 1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错：&quot;Unexpected bound&quot;public &lt;T extends Number&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println(&quot;container key :&quot; + container.getKey()); T test = container.getKey(); return test;&#125; 通过上面的两个例子可以看出：泛型的上下边界添加，必须与泛型的声明在一起 。 4.6 关于泛型数组要提一下看到了很多文章中都会提起泛型数组，经过查看sun的说明文档，在java中是”不能创建一个确切的泛型类型的数组”的。 也就是说下面的这个例子是不可以的： 1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10]; 而使用通配符创建泛型数组是可以的，如下面这个例子： 1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10]; 这样也是可以的： 1List&lt;String&gt;[] ls = new ArrayList[10]; 下面使用Sun的一篇文档的一个例子来说明这个问题： 1234567List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException. 123这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。 下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。 1234567List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type. Object o = lsa; Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Correct. Integer i = (Integer) lsa[1].get(0); // OK 5. 最后本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。","categories":[],"tags":[]},{"title":"markdown语法","slug":"markdown语法","date":"2021-09-15T01:55:13.000Z","updated":"2021-09-23T07:27:55.000Z","comments":true,"path":"2021/09/15/markdown语法/","link":"","permalink":"http://example.com/2021/09/15/markdown%E8%AF%AD%E6%B3%95/","excerpt":"","text":"一、标题在想要设置为标题的文字前面加#来表示 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 示例： 123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 二、字体 加粗 要加粗的文字左右分别用两个*号包起来 斜体 要倾斜的文字左右分别用一个*号包起来 斜体加粗 要倾斜和加粗的文字左右分别用三个*号包起来 删除线 要加删除线的文字左右分别用两个~~号包起来 示例： 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt; n个… 示例： 123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 效果如下： 这是引用的内容 这是引用的内容 这是引用的内容 四、分割线三个或者三个以上的 - 或者 * 都可以。 示例： 1234-------******** 效果如下： 可以看到，显示效果是一样的。 五、图片语法： 1234![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 示例： 12![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg &quot;区块链&quot;) 效果如下： blockchain 上传本地图片直接点击导航栏的图片标志，选择图片即可 六、超链接语法： 12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下： 简书 百度 注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。 1234&lt;a href=&quot;超链接地址&quot; target=&quot;_blank&quot;&gt;超链接名&lt;/a&gt;示例&lt;a href=&quot;https://www.jianshu.com/u/1f5ac0cf6a8b&quot; target=&quot;_blank&quot;&gt;简书&lt;/a&gt; 七、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 12345- 列表内容+ 列表内容* 列表内容注意：- + * 跟内容之间都要有一个空格 效果如下： 列表内容 列表内容 列表内容 有序列表 语法： 数字加点 123451.列表内容2.列表内容3.列表内容注意：序号跟内容之间要有空格 效果如下： 1.列表内容 2.列表内容 3.列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 一级无序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级无序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级有序列表内容 二级有序列表内容 二级有序列表内容 八、表格语法： 1234567891011表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|技能|排行--|:--:|--:刘备|哭|大哥关羽|打|二哥张飞|骂|三弟 效果如下： 姓名 技能 排行 刘备 哭 大哥 关羽 打 二哥 张飞 骂 三弟 九、代码语法： 单行代码：代码之间分别用一个反引号包起来 1`代码内容` 代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行 12345(```) 代码... 代码... 代码...(```) 注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。 示例： 单行代码 1`create database hero;` 代码块 123456(```) function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;; &#125; fun();(```) 效果如下： 单行代码 1create database hero; 代码块 1234function fun()&#123; echo &quot;这是一句非常牛逼的代码&quot;;&#125;fun();","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"}]},{"title":"中文标题","slug":"中文标题","date":"2021-09-12T05:55:04.000Z","updated":"2021-09-12T05:57:13.000Z","comments":true,"path":"2021/09/12/中文标题/","link":"","permalink":"http://example.com/2021/09/12/%E4%B8%AD%E6%96%87%E6%A0%87%E9%A2%98/","excerpt":"","text":"中文标题文字 二级标题EnglishThis is ~.","categories":[{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"}],"tags":[{"name":"中文测试","slug":"中文测试","permalink":"http://example.com/tags/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/"}]},{"title":"test","slug":"test","date":"2021-05-08T03:18:14.000Z","updated":"2021-05-08T03:39:28.000Z","comments":true,"path":"2021/05/08/test/","link":"","permalink":"http://example.com/2021/05/08/test/","excerpt":"","text":"测试文字","categories":[{"name":"文字","slug":"文字","permalink":"http://example.com/categories/%E6%96%87%E5%AD%97/"}],"tags":[{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"Java","slug":"Java","permalink":"http://example.com/categories/Java/"},{"name":"测试","slug":"测试","permalink":"http://example.com/categories/%E6%B5%8B%E8%AF%95/"},{"name":"文字","slug":"文字","permalink":"http://example.com/categories/%E6%96%87%E5%AD%97/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://example.com/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"Java并发","slug":"Java并发","permalink":"http://example.com/tags/Java%E5%B9%B6%E5%8F%91/"},{"name":"markdown","slug":"markdown","permalink":"http://example.com/tags/markdown/"},{"name":"中文测试","slug":"中文测试","permalink":"http://example.com/tags/%E4%B8%AD%E6%96%87%E6%B5%8B%E8%AF%95/"},{"name":"测试","slug":"测试","permalink":"http://example.com/tags/%E6%B5%8B%E8%AF%95/"}]}